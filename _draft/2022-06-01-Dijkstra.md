---
layout: post
title: Dijkstra Algorithm
date: 2022-06-01
author: Shadow Walker
tags: [Graph, Algorithm]
toc: true
comments: true
---


## Overview

According to [Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), Dijkstra includes DP and Greedy. Greedy happens in PQ, we always go to the shortest one first. DP happens in the distMap, we dynamicly update our distance during each search. 

Dijkstra has many variations. Traditional Dijkstra is to search from one given node and find all the shortest distance in the connections. 

## 栗子

### 743 Network Delay Time

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        
        // Build a hashmap graph
        Map<Integer, List<Edge>> graph = new HashMap<>();
        for(int i = 1; i <= n; i ++){
            graph.put(i, new ArrayList<>());
        }
        for(int[] time: times){
            graph.get(time[0]).add(new Edge(time[1], time[2]));
        }
        
        // Build distMap to record the shortest distance to each node. 
        Map<Integer, Integer> distMap = new HashMap<>();
        for(int i = 1; i <= n; i ++){
            distMap.put(i, Integer.MAX_VALUE);
        }
        distMap.put(k, 0);
        
        // Build PQ
        PriorityQueue<Edge> pq = new PriorityQueue<>((a,b) -> a.dist - b.dist);
        pq.add(new Edge(k, 0));
        
        while(!pq.isEmpty()){
            Edge pick = pq.poll();
            int node = pick.con;
            int dist = pick.dist;
            for(Edge edge : graph.get(node)){
                int newDist = dist + edge.dist;
                int nei = edge.con;
                if(newDist < distMap.get(nei)){
                    distMap.put(nei, newDist);
                    pq.add(new Edge(nei, newDist));
                }
            }
        }
        
        int output = 0;
        for (int val: distMap.values()){
            output = Math.max(val, output);
        }
        
        if(output > 6000){
            return -1;
        }
        return output;
    }
}

class Edge{
    int con, dist;
    public Edge(int con, int d){
        this.con = con;
        this.dist = d;
    }
}
```

## Time complexity

- time complexity : `O (V + E*logV) `

## FAQ

### Do we have to use PQ? 

Not necessarily. PQ is the greedy approach. You can use Queue instead. there is no difference. 

However, PQ is faster and will greatly reduce our time complexity. 

787 不能用PQ, 只能用Queue, 想想为什么. 

## Problems

- [2022 Google onsite 原题: Break one wall](https://leetcode.com/discuss/interview-question/353827/Google-or-Onsite-or-Shortest-Path-Breaking-Through-Walls/320514)
- [Fly schedule](https://leetcode.com/discuss/interview-question/1670250/google-phone-airplane-schedule)
- Leetcode 787 对比 743, PQ对比Queue
